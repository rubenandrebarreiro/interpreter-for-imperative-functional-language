PARSER_BEGIN(Parser)

import abstractsyntaxtree.node.*;
import abstractsyntaxtree.node.arithmetic.*;
import abstractsyntaxtree.node.atomic.*;

/** ID lister. */
public class Parser {

	/** Main entry point. */
  	public static void main(String args[]) {
    	Parser parser = new Parser(System.in);
    	ASTNode exp;

    	while (true) {
    		try {
    			exp = parser.Start();
    			System.out.println( exp.eval() );
    		}
    		catch (Exception e) {
      			System.out.println ("Syntax Error!");
      			parser.ReInit(System.in);
    		}
    	}
  	}
}

PARSER_END(Parser)

SKIP :
{
  " "
| "\t"
| "\r"
}

TOKEN :
{
  < Id: ["a"-"z","A"-"Z"] ( ["a"-"z","A"-"Z","0"-"9"] )* >
  |
  < Num: (["0"-"9"]) + >
  |
  < PLUS : "+" >
  |
  < MINUS : "-">
  |
  < TIMES : "*">
  |
  < DIV : "/">
  |
  < LPAR : "(" >
  |
  < RPAR : ")" >
  |
  < EL: "\n" >
}

ASTNode Start():
{ ASTNode t; }
{
   t = Exp() <EL>
   { return t; }
}

ASTNode Exp() :
{ Token operation;
  ASTNode node1, node2; }
{
     node1 = Term() ( ( operation = <PLUS> | operation = <MINUS> ) node2 = Term() 
                 { if (operation.kind == PLUS) 
                         node1 = new ASTAdd(node1, node2);
                   else
                   		 node1 = new ASTSub(node1, node2);
                 } 
             ) *
     { return node1; } 
}

ASTNode Term() :
{ Token operation;
  ASTNode node1, node2;}
{
     node1 = Fact() ( ( operation = <TIMES> | operation = <DIV> ) node2 = Term()
				{ if (operation.kind == TIMES)
						node1 = new ASTMult(node1, node2);
				  else
				        node1 = new ASTDiv(node1, node2);	
				}
     		 )?
     { return node1; } 
}


ASTNode Fact() :
{ Token num ; 
  ASTNode node;}
{
   ( num = <Num> { node = new ASTNum(Integer.parseInt(num.image)); }
			| <MINUS> num = <Num> { node = new ASTNegativeNum(Integer.parseInt(num.image)); } 
   			| <LPAR> node=Exp() <RPAR> )
   { return node; }
}



















