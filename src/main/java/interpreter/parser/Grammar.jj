PARSER_BEGIN(InterpreterParser)

package main.java.interpreter.parser;

import main.java.abstractsyntaxtree.scopes.Environment;
import main.java.abstractsyntaxtree.scopes.compiler.EnvironmentCompiler;
import main.java.abstractsyntaxtree.node.*;
import main.java.abstractsyntaxtree.node.associations.*;
import main.java.abstractsyntaxtree.node.arithmetic.*;
import main.java.abstractsyntaxtree.node.atomics.*;
import main.java.abstractsyntaxtree.node.logics.*;
import main.java.abstractsyntaxtree.node.relationals.*;
import main.java.compiler.Compiler;
import main.java.values.*;
import main.java.values.atomic.*;
import main.java.values.exceptions.*;

import java.util.*;
import java.io.*;

/** ID lister. */
public class InterpreterParser {

static InterpreterParser parser = null;

	/** Main entry point. */
  	public static void main(String args[]) {
  	  	Environment env = new Environment();
    	InterpreterParser interpreterParser = new InterpreterParser(System.in);
    	ASTNode exp;
		while(true) { 
    		try {
    			exp = interpreterParser.Start();
    			Compiler compiler = new Compiler( exp );
    			compiler.generateJavaByteCodeJVMInstructions("Main.j");
    			exp.eval(env).show();
    		}
    		catch (Exception exception) {
    		    exception.printStackTrace();
      			System.err.println ("Syntax Error!!!");
      			interpreterParser.ReInit(System.in);
    		}
    	}
	}

	public static void testInterpreter(InputStream in) {
  	  	Environment env = new Environment();
  	  	if(parser == null)
    		parser = new InterpreterParser(in);
    	else
    		ReInit(in);
    	ASTNode exp;
    	try {
    	    exp = parser.Start();
    		exp.eval(env).show();
    	} catch (Exception e) {
			e.printStackTrace();
    	}
	}

		public static void testCompiler(InputStream in) {
  	  	Environment env = new Environment();
  	  	if(parser == null)
    		parser = new InterpreterParser(in);
    	else
    		ReInit(in);
    	ASTNode exp;
    	try {
    	    exp = parser.Start();
    	    Compiler compiler = new Compiler( exp );
    		compiler.generateJavaByteCodeJVMInstructions("Main.j");
    		exp.eval(env).show();
    	} catch (Exception e) {
			e.printStackTrace();
    	}
	}
}


PARSER_END(InterpreterParser)

SKIP :
{
  " "
| "\t"
| "\r"
}

TOKEN :
{
  < BOOL_VALUE: ("true" | "false") >
  |
  < LET: "Let" | "let" | "Decl" | "decl">
  |
  < IN: "in" >
  |
  < END: "end" >
  |
  < Id: ["a"-"z","A"-"Z"] ( ["a"-"z","A"-"Z","0"-"9"] )* >
  |
  < Num: (["0"-"9"]) + >
  |
  < GREATER_THAN : ">">
  |
  < GREATER_OR_EQUAL : ">=" >
  |
  < LESS_THAN: "<" >
  |
  < LESS_OR_EQUAL: "<=" >
  |
  < NOT: "Not" | "not" | "~" >
  |
  < AND: "And" | "and" | "&&" >
  |
  < OR: "Or" | "or" | "||" >
  |
  < XOR: "Xor" | "xor" | "^" >
  |
  < PLUS : "+" | "plus" >
  |
  < MINUS : "-" | "minus">
  |
  < TIMES : "*" | "times" > 
  |
  < DIV : "/" | "div" >
  |
  < LPAR : "(" >
  |
  < RPAR : ")" >
  |
  < EL: "\n" >
  |
  < EQUAL: "=" >
}

ASTNode Start():
{ ASTNode t; }
{
   t = Exp() <EL>
   { return t; }
}

ASTNode Exp() :
{ Token operation;
  ASTNode node1, node2; }
{
     node1 = Term() ( ( operation = <PLUS> | operation = <MINUS> ) node2 = Term() 
                 { if (operation.kind == PLUS) 
                         node1 = new ASTAdd(node1, node2);
                   else
                   		 node1 = new ASTSub(node1, node2);
                 } 
             ) *
     { return node1; } 
}

ASTNode Term() :
{ Token operation;
  ASTNode node1, node2;}
{
     node1 = Fact() ( ( operation = <TIMES> | operation = <DIV> ) node2 = Term()
				{ if (operation.kind == TIMES)
						node1 = new ASTMult(node1, node2);
				  else
				        node1 = new ASTDiv(node1, node2);	
				}
     		 )?
     { return node1; } 
}


ASTNode Fact() :
{ Token id, value, bodyExpression, num, booleanValue; 
  ASTNode node;
  }
{
   (    booleanValue = <BOOL_VALUE> { node = new ASTBool(new VBool(Boolean.parseBoolean(booleanValue.image))); } 
        | node = Let() 
		| id = <Id> {
		  node = new ASTID(id.image);
		}
		| num = <Num> { node = new ASTNum(new VInt(Integer.parseInt(num.image))); }
		| <MINUS> num = <Num> { node = new ASTNegativeNum(new VNegativeInt(Integer.parseInt(num.image))); }
		| <LPAR> node = Exp() <RPAR> )
   { return node; }
}

ASTNode Logic() :
{ Token operation;
  ASTNode node1, node2;}
{
     node1 = Fact() ( ( operation = <AND> | operation = <OR> |
     					operation = <XOR>) node2 = Fact()
				{ if (operation.kind == AND) 
						node1 = new ASTAnd(node1, node2);
				  else if (operation.kind == OR)
				        node1 = new ASTOr(node1, node2);
				  else
				  		node1 = new ASTXor(node1, node2);	
				}
     		 )*
     { System.out.println("AAAAA");
     return node1; } 
}

ASTNode Let() :
{
  Token bodyExpression;
  ASTNode expressionNode, letNode;
  List<ASTNode> associations;
}
{
  
	(
	  <LET>
      associations = Association()
	  <IN>
	  expressionNode = Exp()
	  <END>
	  { letNode = new ASTLet(associations, expressionNode); }	)
	{ return letNode; }
}

List<ASTNode> Association():
{
  Token id;
  ASTNode associationsNode, idNode, valueNode;
  List<ASTNode> associations = new ArrayList<ASTNode>();
}
{
    (      id = <Id> <EQUAL> { valueNode = Exp(); }
      { associations.add(new ASTAssociation(id.image, valueNode)); }
    )+
    { return associations; }
}

ASTNode Relational() :
{ Token operation;
  ASTNode node1, node2;}
{
     node1 = Exp() ( ( operation = <GREATER_THAN> | operation = <GREATER_OR_EQUAL> |
     				   operation = <LESS_THAN> | operation = <LESS_OR_EQUAL> |
     				   operation = <EQUAL> ) node2 = Exp()
				{ if (operation.kind == GREATER_THAN) 
						node1 = new ASTGreaterThan(node1, node2);
				  else if (operation.kind == GREATER_OR_EQUAL)
				        node1 = new ASTGreaterOrEqualTo(node1, node2);
				  else if (operation.kind == LESS_THAN)
				  		node1 = new ASTLessThan(node1, node2);
				  else if (operation.kind == LESS_OR_EQUAL)
				  		node1 = new ASTLessOrEqualTo(node1, node2);
				  else
				  		node1 = new ASTEqualTo(node1, node2);	
				}
     		 )*
     { return node1; } 
}