PARSER_BEGIN(InterpreterParser)

package main.java.interpreter.parser;

import main.java.abstractsyntaxtree.scopes.Environment;
import main.java.abstractsyntaxtree.scopes.compiler.EnvironmentCompiler;
import main.java.abstractsyntaxtree.node.*;
import main.java.abstractsyntaxtree.node.associations.*;
import main.java.abstractsyntaxtree.node.arithmetic.*;
import main.java.abstractsyntaxtree.node.atomics.*;
import main.java.abstractsyntaxtree.node.conditionals.*;
import main.java.abstractsyntaxtree.node.logics.*;
import main.java.abstractsyntaxtree.node.loops.*;
import main.java.abstractsyntaxtree.node.relationals.*;
import main.java.compiler.Compiler;
import main.java.values.*;
import main.java.values.atomic.*;
import main.java.values.exceptions.*;

import java.util.*;
import java.io.*;

/** ID lister. */
public class InterpreterParser {

	static InterpreterParser parser = null;

	/** Main entry point. */
  	public static void main(String args[]) {

  	  	Environment env = new Environment();
    	InterpreterParser interpreterParser = new InterpreterParser(System.in);

    	ASTNode Num_Exp;
    	
		while(true) { 
    		try {
    			Num_Exp = interpreterParser.Start();
    			Compiler compiler = new Compiler( Num_Exp );
    			compiler.generateJavaByteCodeJVMInstructions("Main.j");
    			Num_Exp.eval(env).show();
    		}
    		catch (Exception exception) {
    		    exception.printStackTrace();
      			System.err.println ("Syntax Error!!!");
      			interpreterParser.ReInit(System.in);
    		}
    	}
	}

	public static void testInterpreter(InputStream in) {
  	  	Environment env = new Environment();

  	  	if(parser == null) { 
    		parser = new InterpreterParser(in);
   		}
   		else { 
    		ReInit(in);
        }

    	ASTNode Num_Exp;

    	try {
    	    Num_Exp = parser.Start();
    		Num_Exp.eval(env).show();
    	}
    	catch (Exception e) {
			e.printStackTrace();
    	}
	}

	public static void testCompiler(InputStream in) {
  	  	Environment env = new Environment();

  	  	if(parser == null) { 
    		parser = new InterpreterParser(in);
        }
    	else { 
    		ReInit(in);
        }

        ASTNode Num_Exp;

    	try {
    	    Num_Exp = parser.Start();

    	    Compiler compiler = new Compiler( Num_Exp );
    		compiler.generateJavaByteCodeJVMInstructions("Main.j");

    		Num_Exp.eval(env).show();
    	}
    	catch (Exception e) {
			e.printStackTrace();
    	}
	}
}

PARSER_END(InterpreterParser)

SKIP :
{
  " "
| "\t"
| "\r"
}

TOKEN :
{
  < BOOL_VALUE: "True" | "true" | "False" | "false" >
  |
  < NEW_REF: "New" | "new" >
  |
  < EXCLAMATION_DREF: "!">
  | 
  < IF: "If" | "if" >
  |
  < THEN: "Then" | "then" >
  |
  < ELSE: "Else" | "else" >
  |
  < WHILE: "While" | "while" >
  |
  < DO: "Do" | "do" >     
  | 
  < LET: "Let" | "let" | "Decl" | "decl" >
  |
  < EQUAL: "==" >
  | 
  < LET_ASSIGN: "=" >
  |
  < IN: "In" | "in" >
  |
  < END: "End" | "end" >
  |
  < NUM: (["0"-"9"]) + >
  |
  < GREATER_THAN : ">">
  |
  < GREATER_OR_EQUAL : ">=" >
  |
  < LESS_THAN: "<" >
  |
  < LESS_OR_EQUAL: "<=" >
  |
  < NOT: "Not" | "not" | "~" >
  |
  < AND: "And" | "and" | "&&" >
  |
  < OR: "Or" | "or" | "||" >
  |
  < XOR: "Xor" | "xor" | "^" >
  |
  < PLUS : "+" | "plus" >
  |
  < MINUS : "-" | "minus">
  |
  < TIMES : "*" | "times" > 
  |
  < DIV : "/" | "div" >
  |
  < LPAR : "(" >
  |
  < RPAR : ")" >
  |
  < EL: "\n" >
  |
  < ID: ["a"-"z","A"-"Z"] ( ["a"-"z","A"-"Z","0"-"9"] )* > 
}

ASTNode Start():
{
  ASTNode t;
}
{
	t = BoolExp() <EL>
   	{
   		return t;
   	}
}

ASTNode BoolExp() :
{
  Token operation;
  ASTNode node1, node2;
}
{
     node1 = BoolTerm() (
		( operation = <OR> | operation = <XOR> ) node2 = BoolExp()
			{
		  		if (operation.kind == OR) 
                	node1 = new ASTOr(node1, node2);
                else
                	node1 = new ASTXor(node1, node2);
             } 
        )*
     {
     	return node1;
     } 
}

ASTNode BoolTerm() :
{
  Token operation;
  ASTNode node1, node2;
}
{
     node1 = Relational() (
	 	( operation = <AND> ) node2 = BoolTerm()
	 		{
        		if (operation.kind == AND)
			 		node1 = new ASTAnd(node1, node2);	
			 }
     	)?
     {
     	return node1;
     } 
}

ASTNode Relational() :
{ Token operation;
  ASTNode node1, node2;}
{
     node1 = NumExp() (
     	( operation = <GREATER_THAN> | operation = <GREATER_OR_EQUAL> |
     	  operation = <LESS_THAN> | operation = <LESS_OR_EQUAL> |
     	  operation = <EQUAL> ) node2 = NumExp()
			{
				if (operation.kind == GREATER_THAN) 
					node1 = new ASTGreaterThan(node1, node2);
				else if (operation.kind == GREATER_OR_EQUAL)
				    node1 = new ASTGreaterOrEqualTo(node1, node2);
				else if (operation.kind == LESS_THAN)
					node1 = new ASTLessThan(node1, node2);
				else if (operation.kind == LESS_OR_EQUAL)
					node1 = new ASTLessOrEqualTo(node1, node2);
				else
					node1 = new ASTEqualTo(node1, node2);	
			}
     	)?
	{
    	return node1;
    } 
}

/*ASTNode GenericExp() :
{
  ASTNode node;
}
{
  (
  	 node = NumExp()
     | node = BoolExp()
  )
  {
  	return node;
  } 
}*/

ASTNode NumExp() :
{
  Token operation;
  ASTNode node1, node2;
}
{
     (       node1 = NumTerm() (
     	( operation = <PLUS> | operation = <MINUS> ) node2 = NumTerm() 
     		{
				if (operation.kind == PLUS) 
                	node1 = new ASTAdd(node1, node2);
                else
                   	node1 = new ASTSub(node1, node2);
            } 
        )*
        )
     {
     	return node1;
     } 
}

ASTNode NumTerm() :
{
  Token operation;
  ASTNode node1, node2;
}
{
     node1 = Fact() (
       ( operation = <TIMES> | operation = <DIV> ) node2 = NumTerm()
			{
			  if (operation.kind == TIMES)
			  		node1 = new ASTMult(node1, node2);
			  else
				    node1 = new ASTDiv(node1, node2);	
			}
     	)?
     {
       return node1;
     } 
}

ASTNode Fact() :
{
  Token id, value, bodyNum_Expression, num, booleanValue; 
  ASTNode node;
}
{
   (
     	num = <NUM> {
			node = new ASTNum(new VInt(Integer.parseInt(num.image)));
		}
		| <MINUS> num = <NUM> {
		  	node = new ASTNegativeNum(new VNegativeInt(Integer.parseInt(num.image)));
		}
		| booleanValue = <BOOL_VALUE> {
     	  	node = new ASTBool(new VBool(Boolean.parseBoolean(booleanValue.image)));
     	}
        | <NOT> booleanValue = <BOOL_VALUE> {
		  	node = new ASTNotBool(new VBool(Boolean.parseBoolean(booleanValue.image)));
        } 
     	| id = <ID> {
		  	node = new ASTID(id.image);
		} 
        | node = Let()
		| <LPAR> node = BoolExp() <RPAR>
		| <NEW_REF> node = Fact()
		| <EXCLAMATION_DREF> node = Fact()
	    | node = Conditional()
	    | node = Loop()
	)
    {
      return node;
    }
}

ASTNode Let() :
{
  ASTNode expressionNode, letNode;
  
  List<ASTNode> associations;
}
{
	(
		<LET>
      	associations = Association()
	  	<IN>
	  	expressionNode = NumExp()
	  	<END>
	  	{
	  	  letNode = new ASTLet(associations, expressionNode);
	  	}	)
	{
	  return letNode;
	}
}

List<ASTNode> Association():
{
  Token id;
  ASTNode associationsNode, idNode, valueNode;
  
  List<ASTNode> associations = new ArrayList<ASTNode>();
}
{
    (      id = <ID> <LET_ASSIGN>
      	{
      	  valueNode = NumExp();
      	}
      	{
        	associations.add(new ASTAssociation(id.image, valueNode));
      	}
    )+
    {
      return associations;
    }
}

ASTNode Conditional():
{
  ASTNode ifASTNode, thenASTNode, elseASTNode,
          ifThenElseNode;
}
{
	(
		<IF>
      	ifASTNode = BoolExp()
	  	<THEN>
	  	thenASTNode = BoolExp()
	  	<ELSE>
	  	elseASTNode = BoolExp()
	  	{
	  	  ifThenElseNode = new ASTIfThenElse(ifASTNode, thenASTNode, elseASTNode);
	  	}
	)
	{
	  return ifThenElseNode;
	}
}

ASTNode Loop() :
{
  ASTNode conditionWhileNode, instructionSetWhileNode,
          whileNode;
}
{
	(
		<WHILE>
      	conditionWhileNode = BoolExp()
	  	<DO>
	  	instructionSetWhileNode = BoolExp() //ASTSeq()
	  	<END>
	  	{
	  	  whileNode = new ASTWhile(conditionWhileNode, instructionSetWhileNode);
	  	}
	)
	{
	  return whileNode;
	}
}